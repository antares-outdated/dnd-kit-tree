{"ast":null,"code":"import _slicedToArray from \"C:/Users/antaresofficial/Desktop/tree/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"C:/Users/antaresofficial/Desktop/tree/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getBoundingClientRect, useDroppable, useDraggable, getViewRect, closestCorners, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs } from '@dnd-kit/utilities';\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\n\nfunction arrayMove(array, from, to) {\n  var newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\n\nfunction getSortedRects(items, layoutRects) {\n  return items.reduce(function (accumulator, id, index) {\n    var layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n} // To-do: We should be calculating scale transformation\n\n\nvar defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\n\nvar horizontalListSortingStrategy = function horizontalListSortingStrategy(_ref) {\n  var layoutRects = _ref.layoutRects,\n      fallbackActiveRect = _ref.activeNodeRect,\n      activeIndex = _ref.activeIndex,\n      overIndex = _ref.overIndex,\n      index = _ref.index;\n\n  var _layoutRects$activeIn;\n\n  var activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  var itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    var newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return _objectSpread({\n      x: activeIndex < overIndex ? newIndexRect.offsetLeft + newIndexRect.width - (activeNodeRect.offsetLeft + activeNodeRect.width) : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0\n    }, defaultScale);\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return _objectSpread({\n      x: -activeNodeRect.width - itemGap,\n      y: 0\n    }, defaultScale);\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return _objectSpread({\n      x: activeNodeRect.width + itemGap,\n      y: 0\n    }, defaultScale);\n  }\n\n  return _objectSpread({\n    x: 0,\n    y: 0\n  }, defaultScale);\n};\n\nfunction getItemGap(layoutRects, index, activeIndex) {\n  var currentRect = layoutRects[index];\n  var previousRect = layoutRects[index - 1];\n  var nextRect = layoutRects[index + 1];\n\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width) : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width) : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n\nvar rectSortingStrategy = function rectSortingStrategy(_ref2) {\n  var layoutRects = _ref2.layoutRects,\n      activeIndex = _ref2.activeIndex,\n      overIndex = _ref2.overIndex,\n      index = _ref2.index;\n  var newRects = arrayMove(layoutRects, overIndex, activeIndex);\n  var oldRect = layoutRects[index];\n  var newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\nvar rectSwappingStrategy = function rectSwappingStrategy(_ref3) {\n  var activeIndex = _ref3.activeIndex,\n      index = _ref3.index,\n      layoutRects = _ref3.layoutRects,\n      overIndex = _ref3.overIndex;\n  var oldRect;\n  var newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n}; // To-do: We should be calculating scale transformation\n\n\nvar defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\n\nvar verticalListSortingStrategy = function verticalListSortingStrategy(_ref4) {\n  var activeIndex = _ref4.activeIndex,\n      fallbackActiveRect = _ref4.activeNodeRect,\n      index = _ref4.index,\n      layoutRects = _ref4.layoutRects,\n      overIndex = _ref4.overIndex;\n\n  var _layoutRects$activeIn;\n\n  var activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    var overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return _objectSpread({\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.offsetTop + overIndexRect.height - (activeNodeRect.offsetTop + activeNodeRect.height) : overIndexRect.offsetTop - activeNodeRect.offsetTop\n    }, defaultScale$1);\n  }\n\n  var itemGap = getItemGap$1(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return _objectSpread({\n      x: 0,\n      y: -activeNodeRect.height - itemGap\n    }, defaultScale$1);\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return _objectSpread({\n      x: 0,\n      y: activeNodeRect.height + itemGap\n    }, defaultScale$1);\n  }\n\n  return _objectSpread({\n    x: 0,\n    y: 0\n  }, defaultScale$1);\n};\n\nfunction getItemGap$1(layoutRects, index, activeIndex) {\n  var currentRect = layoutRects[index];\n  var previousRect = layoutRects[index - 1];\n  var nextRect = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : 0;\n  }\n\n  return nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : 0;\n}\n\nvar ID_PREFIX = 'Sortable';\nvar Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {\n    current: false\n  }\n});\n\nfunction SortableContext(_ref5) {\n  var children = _ref5.children,\n      id = _ref5.id,\n      userDefinedItems = _ref5.items,\n      _ref5$strategy = _ref5.strategy,\n      strategy = _ref5$strategy === void 0 ? rectSortingStrategy : _ref5$strategy;\n\n  var _useDndContext = useDndContext(),\n      active = _useDndContext.active,\n      overlayNode = _useDndContext.overlayNode,\n      droppableRects = _useDndContext.droppableRects,\n      over = _useDndContext.over,\n      recomputeLayouts = _useDndContext.recomputeLayouts,\n      willRecomputeLayouts = _useDndContext.willRecomputeLayouts;\n\n  var containerId = useUniqueId(ID_PREFIX, id);\n  var useDragOverlay = Boolean(overlayNode.rect !== null);\n  var items = useMemo(function () {\n    return userDefinedItems.map(function (item) {\n      return typeof item === 'string' ? item : item.id;\n    });\n  }, [userDefinedItems]);\n  var activeIndex = active ? items.indexOf(active.id) : -1;\n  var isSorting = activeIndex !== -1;\n  var wasSorting = useRef(isSorting);\n  var overIndex = over ? items.indexOf(over.id) : -1;\n  var previousItemsRef = useRef(items);\n  var sortedRects = getSortedRects(items, droppableRects);\n  var itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  var disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  useIsomorphicLayoutEffect(function () {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n  useEffect(function () {\n    previousItemsRef.current = items;\n  }, [items]);\n  useEffect(function () {\n    requestAnimationFrame(function () {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n  var contextValue = useMemo(function () {\n    return {\n      activeIndex: activeIndex,\n      containerId: containerId,\n      disableTransforms: disableTransforms,\n      items: items,\n      overIndex: overIndex,\n      useDragOverlay: useDragOverlay,\n      sortedRects: sortedRects,\n      strategy: strategy,\n      wasSorting: wasSorting\n    };\n  }, [activeIndex, containerId, disableTransforms, items, overIndex, sortedRects, useDragOverlay, strategy, wasSorting]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nfunction isEqual(arr1, arr2) {\n  return arr1.join() === arr2.join();\n}\n\nvar defaultAnimateLayoutChanges = function defaultAnimateLayoutChanges(_ref6) {\n  var isSorting = _ref6.isSorting,\n      index = _ref6.index,\n      newIndex = _ref6.newIndex,\n      transition = _ref6.transition;\n\n  if (!transition) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index;\n};\n\nvar defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nvar transitionProperty = 'transform';\nvar disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nvar defaultAttributes = {\n  roleDescription: 'sortable'\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform(_ref7) {\n  var rect = _ref7.rect,\n      disabled = _ref7.disabled,\n      index = _ref7.index,\n      node = _ref7.node;\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      derivedTransform = _useState2[0],\n      setDerivedtransform = _useState2[1];\n\n  var prevIndex = useRef(index);\n  useEffect(function () {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      var initial = rect.current;\n\n      if (initial) {\n        var current = getBoundingClientRect(node.current);\n        var delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(function () {\n    if (derivedTransform) {\n      requestAnimationFrame(function () {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\n\nfunction useSortable(_ref8) {\n  var _ref8$animateLayoutCh = _ref8.animateLayoutChanges,\n      animateLayoutChanges = _ref8$animateLayoutCh === void 0 ? defaultAnimateLayoutChanges : _ref8$animateLayoutCh,\n      userDefinedAttributes = _ref8.attributes,\n      disabled = _ref8.disabled,\n      customData = _ref8.data,\n      id = _ref8.id,\n      localStrategy = _ref8.strategy,\n      _ref8$transition = _ref8.transition,\n      transition = _ref8$transition === void 0 ? defaultTransition : _ref8$transition;\n\n  var _useContext = useContext(Context),\n      items = _useContext.items,\n      containerId = _useContext.containerId,\n      activeIndex = _useContext.activeIndex,\n      disableTransforms = _useContext.disableTransforms,\n      sortedRects = _useContext.sortedRects,\n      overIndex = _useContext.overIndex,\n      useDragOverlay = _useContext.useDragOverlay,\n      globalStrategy = _useContext.strategy,\n      wasSorting = _useContext.wasSorting;\n\n  var index = items.indexOf(id);\n  var data = useMemo(function () {\n    return _objectSpread({\n      sortable: {\n        containerId: containerId,\n        index: index,\n        items: items\n      }\n    }, customData);\n  }, [containerId, customData, index, items]);\n\n  var _useDroppable = useDroppable({\n    id: id,\n    data: data\n  }),\n      rect = _useDroppable.rect,\n      node = _useDroppable.node,\n      setDroppableNodeRef = _useDroppable.setNodeRef;\n\n  var _useDraggable = useDraggable({\n    id: id,\n    data: data,\n    attributes: _objectSpread(_objectSpread({}, defaultAttributes), userDefinedAttributes),\n    disabled: disabled\n  }),\n      active = _useDraggable.active,\n      activeNodeRect = _useDraggable.activeNodeRect,\n      activatorEvent = _useDraggable.activatorEvent,\n      attributes = _useDraggable.attributes,\n      setDraggableNodeRef = _useDraggable.setNodeRef,\n      listeners = _useDraggable.listeners,\n      isDragging = _useDraggable.isDragging,\n      over = _useDraggable.over,\n      transform = _useDraggable.transform;\n\n  var setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  var isSorting = Boolean(active);\n  var displaceItem = isSorting && wasSorting.current && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  var shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  var dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  var strategy = localStrategy != null ? localStrategy : globalStrategy;\n  var finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    layoutRects: sortedRects,\n    activeNodeRect: activeNodeRect,\n    activeIndex: activeIndex,\n    overIndex: overIndex,\n    index: index\n  }) : null;\n  var newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? arrayMove(items, activeIndex, overIndex).indexOf(id) : index;\n  var prevNewIndex = useRef(newIndex);\n  var shouldAnimateLayoutChanges = animateLayoutChanges({\n    active: active,\n    isDragging: isDragging,\n    isSorting: isSorting,\n    id: id,\n    index: index,\n    items: items,\n    newIndex: prevNewIndex.current,\n    transition: transition,\n    wasSorting: wasSorting.current\n  });\n  var derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index: index,\n    node: node,\n    rect: rect\n  });\n  useEffect(function () {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n  return {\n    active: active,\n    attributes: attributes,\n    activatorEvent: activatorEvent,\n    rect: rect,\n    index: index,\n    isSorting: isSorting,\n    isDragging: isDragging,\n    listeners: listeners,\n    node: node,\n    overIndex: overIndex,\n    over: over,\n    setNodeRef: setNodeRef,\n    setDroppableNodeRef: setDroppableNodeRef,\n    setDraggableNodeRef: setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString(_objectSpread(_objectSpread({}, transition), {}, {\n        property: transitionProperty\n      }));\n    }\n\n    return null;\n  }\n}\n\nvar directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\n\nvar sortableKeyboardCoordinates = function sortableKeyboardCoordinates(event, _ref9) {\n  var _ref9$context = _ref9.context,\n      droppableContainers = _ref9$context.droppableContainers,\n      translatedRect = _ref9$context.translatedRect,\n      scrollableAncestors = _ref9$context.scrollableAncestors;\n\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!translatedRect) {\n      return;\n    }\n\n    var layoutRects = [];\n    Object.entries(droppableContainers).forEach(function (_ref10) {\n      var _ref11 = _slicedToArray(_ref10, 2),\n          id = _ref11[0],\n          container = _ref11[1];\n\n      if (container == null ? void 0 : container.disabled) {\n        return;\n      }\n\n      var node = container == null ? void 0 : container.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      var rect = getViewRect(node);\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n\n          break;\n\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n\n          break;\n\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n\n          break;\n\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n\n          break;\n      }\n    });\n    var closestId = closestCorners(layoutRects, translatedRect);\n\n    if (closestId) {\n      var _droppableContainers$;\n\n      var newNode = (_droppableContainers$ = droppableContainers[closestId]) == null ? void 0 : _droppableContainers$.node.current;\n\n      if (newNode) {\n        var newScrollAncestors = getScrollableAncestors(newNode);\n        var hasDifferentScrollAncestors = newScrollAncestors.some(function (element, index) {\n          return scrollableAncestors[index] !== element;\n        });\n        var newRect = getViewRect(newNode);\n        var offset = hasDifferentScrollAncestors ? {\n          x: 0,\n          y: 0\n        } : {\n          x: translatedRect.width - newRect.width,\n          y: translatedRect.height - newRect.height\n        };\n        var newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y\n        };\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nexport { SortableContext, arrayMove, defaultAnimateLayoutChanges, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };","map":{"version":3,"sources":["../src/utilities/arrayMove.ts","../src/utilities/getSortedRects.ts","../src/utilities/isValidIndex.ts","../src/strategies/horizontalListSorting.ts","../src/strategies/rectSorting.ts","../src/strategies/rectSwapping.ts","../src/strategies/verticalListSorting.ts","../src/components/SortableContext.tsx","../src/hooks/defaults.ts","../src/hooks/utilities/useDerivedTransform.ts","../src/hooks/useSortable.ts","../src/sensors/keyboard/sortableKeyboardCoordinates.ts"],"names":["arrayMove","array","from","to","newArray","getSortedRects","items","layoutRects","layoutRect","accumulator","Array","isValidIndex","index","defaultScale","scaleX","scaleY","horizontalListSortingStrategy","activeNodeRect","itemGap","getItemGap","newIndexRect","x","activeIndex","y","currentRect","previousRect","nextRect","rectSortingStrategy","newRects","oldRect","newRect","height","rectSwappingStrategy","overIndex","verticalListSortingStrategy","overIndexRect","ID_PREFIX","Context","containerId","disableTransforms","useDragOverlay","sortedRects","strategy","wasSorting","current","SortableContext","willRecomputeLayouts","useDndContext","useUniqueId","Boolean","overlayNode","useMemo","userDefinedItems","item","active","isSorting","useRef","over","previousItemsRef","itemsHaveChanged","isEqual","useIsomorphicLayoutEffect","recomputeLayouts","useEffect","requestAnimationFrame","contextValue","value","arr1","arr2","defaultAnimateLayoutChanges","transition","newIndex","defaultTransition","duration","easing","transitionProperty","disabledTransition","property","defaultAttributes","roleDescription","useDerivedTransform","node","useState","prevIndex","initial","rect","getBoundingClientRect","delta","setDerivedtransform","useSortable","animateLayoutChanges","attributes","data","useContext","sortable","customData","setNodeRef","setDroppableNodeRef","useDroppable","id","transform","useDraggable","userDefinedAttributes","disabled","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","localStrategy","finalTransform","prevNewIndex","shouldAnimateLayoutChanges","isDragging","derivedTransform","activatorEvent","listeners","setDraggableNodeRef","getTransition","directions","KeyboardCode","sortableKeyboardCoordinates","context","scrollableAncestors","event","Object","container","getViewRect","translatedRect","closestId","closestCorners","newNode","droppableContainers","newScrollAncestors","getScrollableAncestors","hasDifferentScrollAncestors","offset","newCoordinates"],"mappings":"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","sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","import type {\n  LayoutRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  layoutRects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<LayoutRect[]>((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.offsetLeft +\n            newIndexRect.width -\n            (activeNodeRect.offsetLeft + activeNodeRect.width)\n          : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width)\n      : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width)\n    : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.offsetTop +\n            overIndexRect.height -\n            (activeNodeRect.offsetTop + activeNodeRect.height)\n          : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n      : nextRect\n      ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n    : previousRect\n    ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n    : 0;\n}\n","import React, {MutableRefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, LayoutRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: LayoutRect[];\n  strategy: SortingStrategy;\n  wasSorting: MutableRefObject<boolean>;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {current: false},\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    overlayNode,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(overlayNode.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const isSorting = activeIndex !== -1;\n  const wasSorting = useRef(isSorting);\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  useEffect(() => {\n    requestAnimationFrame(() => {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects,\n      strategy,\n      wasSorting,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      sortedRects,\n      useDragOverlay,\n      strategy,\n      wasSorting,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  isSorting,\n  index,\n  newIndex,\n  transition,\n}) => {\n  if (!transition) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {useEffect, useRef, useState} from 'react';\nimport {getBoundingClientRect, LayoutRect} from '@dnd-kit/core';\nimport type {Transform} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<LayoutRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({rect, disabled, index, node}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const prevIndex = useRef(index);\n\n  useEffect(() => {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {useDraggable, useDroppable, UseDraggableArguments} from '@dnd-kit/core';\nimport {CSS, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {arrayMove, isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments extends UseDraggableArguments {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasSorting,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const {rect, node, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n  });\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    wasSorting.current &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        layoutRects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? arrayMove(items, activeIndex, overIndex).indexOf(id)\n      : index;\n  const prevNewIndex = useRef(newIndex);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    transition,\n    wasSorting: wasSorting.current,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return null;\n  }\n}\n","import {\n  closestCorners,\n  getViewRect,\n  getScrollableAncestors,\n  KeyboardCode,\n  RectEntry,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {droppableContainers, translatedRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!translatedRect) {\n      return;\n    }\n\n    const layoutRects: RectEntry[] = [];\n\n    Object.entries(droppableContainers).forEach(([id, container]) => {\n      if (container?.disabled) {\n        return;\n      }\n\n      const node = container?.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      const rect = getViewRect(node);\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n      }\n    });\n\n    const closestId = closestCorners(layoutRects, translatedRect);\n\n    if (closestId) {\n      const newNode = droppableContainers[closestId]?.node.current;\n\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: translatedRect.width - newRect.width,\n              y: translatedRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n"]},"metadata":{},"sourceType":"module"}