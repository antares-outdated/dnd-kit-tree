{"ast":null,"code":"// Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\nexport var formatToSchema = function formatToSchema(format) {\n  if (!format) return undefined;\n  var result = [];\n  var i = 0;\n  var part;\n\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n\n    i += 1;\n  }\n\n  if (part) result.push(part);\n  return result;\n}; // convert value into text representation using the schema\n\nexport var valueToText = function valueToText(value, schema) {\n  // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n  if (!value || Array.isArray(value) && !value.length) return '';\n  var text = '';\n  var dates = (Array.isArray(value) ? value : [value]).map(function (v) {\n    return new Date(v);\n  });\n  var dateIndex = 0;\n  var parts = {};\n  schema.forEach(function (part) {\n    var _char = part[0].toLowerCase(); // advance dateIndex if we already have this part\n\n\n    while (dateIndex < dates.length && (Number.isNaN(dates[dateIndex].date) || (_char === 'm' || _char === 'd' || _char === 'y') && parts[part])) {\n      dateIndex += 1;\n      parts = {};\n    }\n\n    var date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += (\"0\" + (date.getMonth() + 1)).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += (\"0\" + date.getDate()).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else text += part;\n  });\n  return text;\n};\nvar charCodeZero = '0'.charCodeAt(0);\nvar charCodeNine = '9'.charCodeAt(0);\n\nvar pullDigits = function pullDigits(text, index) {\n  var end = index;\n\n  while (text.charCodeAt(end) >= charCodeZero && text.charCodeAt(end) <= charCodeNine) {\n    end += 1;\n  }\n\n  return text.slice(index, end);\n};\n\nexport var textToValue = function textToValue(text, schema) {\n  if (!text) return undefined;\n  var result;\n\n  var addDate = function addDate(parts) {\n    // do a little sanity checking on the values\n    if (!parts.m || !parts.d || !parts.y || parts.y.length < 4 || parts.m.length > 2 || parts.d.length > 2 || parts.m > 12 || parts.d > 31) return parts;\n    var date = new Date(parts.y, parts.m - 1, parts.d).toISOString();\n    if (!result) result = date; // single\n    else if (Array.isArray(result)) result.push(date); // second\n    else result = [result, date]; // third and beyond, unused?\n\n    return {};\n  };\n\n  var parts = {};\n  var index = 0;\n  schema.forEach(function (part) {\n    if (index < text.length) {\n      var _char2 = part[0].toLowerCase();\n\n      if (parts[_char2] !== undefined) parts = addDate(parts);\n\n      if (_char2 === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (_char2 === 'd') {\n        parts.d = pullDigits(text, index);\n        index += parts.d.length;\n      } else if (_char2 === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  addDate(parts);\n  return result;\n};","map":{"version":3,"sources":["C:/Users/antaresofficial/Desktop/tree/node_modules/grommet/es6/components/DateInput/utils.js"],"names":["formatToSchema","format","undefined","result","i","part","length","push","valueToText","value","schema","Array","isArray","text","dates","map","v","Date","dateIndex","parts","forEach","_char","toLowerCase","Number","isNaN","date","getMonth","slice","getDate","getFullYear","toString","charCodeZero","charCodeAt","charCodeNine","pullDigits","index","end","textToValue","addDate","m","d","y","toISOString","_char2"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,IAAIA,cAAc,GAAG,SAASA,cAAT,CAAwBC,MAAxB,EAAgC;AAC1D,MAAI,CAACA,MAAL,EAAa,OAAOC,SAAP;AACb,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,IAAJ;;AAEA,SAAOD,CAAC,GAAGH,MAAM,CAACK,MAAlB,EAA0B;AACxB,QAAI,CAACD,IAAD,IAASA,IAAI,CAAC,CAAD,CAAJ,KAAYJ,MAAM,CAACG,CAAD,CAA/B,EAAoC;AAClC,UAAIC,IAAJ,EAAUF,MAAM,CAACI,IAAP,CAAYF,IAAZ;AACVA,MAAAA,IAAI,GAAGJ,MAAM,CAACG,CAAD,CAAb;AACD,KAHD,MAGO;AACLC,MAAAA,IAAI,IAAIJ,MAAM,CAACG,CAAD,CAAd;AACD;;AAEDA,IAAAA,CAAC,IAAI,CAAL;AACD;;AAED,MAAIC,IAAJ,EAAUF,MAAM,CAACI,IAAP,CAAYF,IAAZ;AACV,SAAOF,MAAP;AACD,CAnBM,C,CAmBJ;;AAEH,OAAO,IAAIK,WAAW,GAAG,SAASA,WAAT,CAAqBC,KAArB,EAA4BC,MAA5B,EAAoC;AAC3D;AACA;AACA,MAAI,CAACD,KAAD,IAAUE,KAAK,CAACC,OAAN,CAAcH,KAAd,KAAwB,CAACA,KAAK,CAACH,MAA7C,EAAqD,OAAO,EAAP;AACrD,MAAIO,IAAI,GAAG,EAAX;AACA,MAAIC,KAAK,GAAG,CAACH,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAAhC,EAAyCM,GAAzC,CAA6C,UAAUC,CAAV,EAAa;AACpE,WAAO,IAAIC,IAAJ,CAASD,CAAT,CAAP;AACD,GAFW,CAAZ;AAGA,MAAIE,SAAS,GAAG,CAAhB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACAT,EAAAA,MAAM,CAACU,OAAP,CAAe,UAAUf,IAAV,EAAgB;AAC7B,QAAIgB,KAAK,GAAGhB,IAAI,CAAC,CAAD,CAAJ,CAAQiB,WAAR,EAAZ,CAD6B,CACM;;;AAGnC,WAAOJ,SAAS,GAAGJ,KAAK,CAACR,MAAlB,KAA6BiB,MAAM,CAACC,KAAP,CAAaV,KAAK,CAACI,SAAD,CAAL,CAAiBO,IAA9B,KAAuC,CAACJ,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA3B,IAAkCA,KAAK,KAAK,GAA7C,KAAqDF,KAAK,CAACd,IAAD,CAA9H,CAAP,EAA8I;AAC5Ia,MAAAA,SAAS,IAAI,CAAb;AACAC,MAAAA,KAAK,GAAG,EAAR;AACD;;AAED,QAAIM,IAAI,GAAGX,KAAK,CAACI,SAAD,CAAhB;;AAEA,QAAIO,IAAI,IAAIpB,IAAI,KAAK,GAArB,EAA0B;AACxBQ,MAAAA,IAAI,IAAIY,IAAI,CAACC,QAAL,KAAkB,CAA1B;AACAP,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHD,MAGO,IAAIoB,IAAI,IAAIpB,IAAI,KAAK,IAArB,EAA2B;AAChCQ,MAAAA,IAAI,IAAI,CAAC,OAAOY,IAAI,CAACC,QAAL,KAAkB,CAAzB,CAAD,EAA8BC,KAA9B,CAAoC,CAAC,CAArC,CAAR;AACAR,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHM,MAGA,IAAIoB,IAAI,IAAIpB,IAAI,KAAK,GAArB,EAA0B;AAC/BQ,MAAAA,IAAI,IAAIY,IAAI,CAACG,OAAL,EAAR;AACAT,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHM,MAGA,IAAIoB,IAAI,IAAIpB,IAAI,KAAK,IAArB,EAA2B;AAChCQ,MAAAA,IAAI,IAAI,CAAC,MAAMY,IAAI,CAACG,OAAL,EAAP,EAAuBD,KAAvB,CAA6B,CAAC,CAA9B,CAAR;AACAR,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHM,MAGA,IAAIoB,IAAI,IAAIpB,IAAI,KAAK,IAArB,EAA2B;AAChCQ,MAAAA,IAAI,IAAIY,IAAI,CAACI,WAAL,GAAmBC,QAAnB,GAA8BH,KAA9B,CAAoC,CAAC,CAArC,CAAR;AACAR,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHM,MAGA,IAAIoB,IAAI,IAAIpB,IAAI,KAAK,MAArB,EAA6B;AAClCQ,MAAAA,IAAI,IAAIY,IAAI,CAACI,WAAL,EAAR;AACAV,MAAAA,KAAK,CAACd,IAAD,CAAL,GAAc,IAAd;AACD,KAHM,MAGAQ,IAAI,IAAIR,IAAR;AACR,GA9BD;AA+BA,SAAOQ,IAAP;AACD,CA1CM;AA2CP,IAAIkB,YAAY,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAnB;AACA,IAAIC,YAAY,GAAG,IAAID,UAAJ,CAAe,CAAf,CAAnB;;AAEA,IAAIE,UAAU,GAAG,SAASA,UAAT,CAAoBrB,IAApB,EAA0BsB,KAA1B,EAAiC;AAChD,MAAIC,GAAG,GAAGD,KAAV;;AAEA,SAAOtB,IAAI,CAACmB,UAAL,CAAgBI,GAAhB,KAAwBL,YAAxB,IAAwClB,IAAI,CAACmB,UAAL,CAAgBI,GAAhB,KAAwBH,YAAvE,EAAqF;AACnFG,IAAAA,GAAG,IAAI,CAAP;AACD;;AAED,SAAOvB,IAAI,CAACc,KAAL,CAAWQ,KAAX,EAAkBC,GAAlB,CAAP;AACD,CARD;;AAUA,OAAO,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBxB,IAArB,EAA2BH,MAA3B,EAAmC;AAC1D,MAAI,CAACG,IAAL,EAAW,OAAOX,SAAP;AACX,MAAIC,MAAJ;;AAEA,MAAImC,OAAO,GAAG,SAASA,OAAT,CAAiBnB,KAAjB,EAAwB;AACpC;AACA,QAAI,CAACA,KAAK,CAACoB,CAAP,IAAY,CAACpB,KAAK,CAACqB,CAAnB,IAAwB,CAACrB,KAAK,CAACsB,CAA/B,IAAoCtB,KAAK,CAACsB,CAAN,CAAQnC,MAAR,GAAiB,CAArD,IAA0Da,KAAK,CAACoB,CAAN,CAAQjC,MAAR,GAAiB,CAA3E,IAAgFa,KAAK,CAACqB,CAAN,CAAQlC,MAAR,GAAiB,CAAjG,IAAsGa,KAAK,CAACoB,CAAN,GAAU,EAAhH,IAAsHpB,KAAK,CAACqB,CAAN,GAAU,EAApI,EAAwI,OAAOrB,KAAP;AACxI,QAAIM,IAAI,GAAG,IAAIR,IAAJ,CAASE,KAAK,CAACsB,CAAf,EAAkBtB,KAAK,CAACoB,CAAN,GAAU,CAA5B,EAA+BpB,KAAK,CAACqB,CAArC,EAAwCE,WAAxC,EAAX;AACA,QAAI,CAACvC,MAAL,EAAaA,MAAM,GAAGsB,IAAT,CAAb,CAA4B;AAA5B,SACK,IAAId,KAAK,CAACC,OAAN,CAAcT,MAAd,CAAJ,EAA2BA,MAAM,CAACI,IAAP,CAAYkB,IAAZ,EAA3B,CAA8C;AAA9C,SACEtB,MAAM,GAAG,CAACA,MAAD,EAASsB,IAAT,CAAT,CAN6B,CAMJ;;AAEhC,WAAO,EAAP;AACD,GATD;;AAWA,MAAIN,KAAK,GAAG,EAAZ;AACA,MAAIgB,KAAK,GAAG,CAAZ;AACAzB,EAAAA,MAAM,CAACU,OAAP,CAAe,UAAUf,IAAV,EAAgB;AAC7B,QAAI8B,KAAK,GAAGtB,IAAI,CAACP,MAAjB,EAAyB;AACvB,UAAIqC,MAAM,GAAGtC,IAAI,CAAC,CAAD,CAAJ,CAAQiB,WAAR,EAAb;;AAEA,UAAIH,KAAK,CAACwB,MAAD,CAAL,KAAkBzC,SAAtB,EAAiCiB,KAAK,GAAGmB,OAAO,CAACnB,KAAD,CAAf;;AAEjC,UAAIwB,MAAM,KAAK,GAAf,EAAoB;AAClBxB,QAAAA,KAAK,CAACoB,CAAN,GAAUL,UAAU,CAACrB,IAAD,EAAOsB,KAAP,CAApB;AACAA,QAAAA,KAAK,IAAIhB,KAAK,CAACoB,CAAN,CAAQjC,MAAjB;AACD,OAHD,MAGO,IAAIqC,MAAM,KAAK,GAAf,EAAoB;AACzBxB,QAAAA,KAAK,CAACqB,CAAN,GAAUN,UAAU,CAACrB,IAAD,EAAOsB,KAAP,CAApB;AACAA,QAAAA,KAAK,IAAIhB,KAAK,CAACqB,CAAN,CAAQlC,MAAjB;AACD,OAHM,MAGA,IAAIqC,MAAM,KAAK,GAAf,EAAoB;AACzBxB,QAAAA,KAAK,CAACsB,CAAN,GAAUP,UAAU,CAACrB,IAAD,EAAOsB,KAAP,CAApB;AACAA,QAAAA,KAAK,IAAIhB,KAAK,CAACsB,CAAN,CAAQnC,MAAjB;AACD,OAHM,MAGA,IAAIO,IAAI,CAACc,KAAL,CAAWQ,KAAX,EAAkBA,KAAK,GAAG9B,IAAI,CAACC,MAA/B,MAA2CD,IAA/C,EAAqD;AAC1D8B,QAAAA,KAAK,IAAI9B,IAAI,CAACC,MAAd;AACD,OAFM,MAEA;AACL;AACA6B,QAAAA,KAAK,GAAGtB,IAAI,CAACP,MAAb;AACAH,QAAAA,MAAM,GAAGD,SAAT;AACD;AACF;AACF,GAvBD;AAwBAoC,EAAAA,OAAO,CAACnB,KAAD,CAAP;AACA,SAAOhB,MAAP;AACD,CA3CM","sourcesContent":["// Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\nexport var formatToSchema = function formatToSchema(format) {\n  if (!format) return undefined;\n  var result = [];\n  var i = 0;\n  var part;\n\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n\n    i += 1;\n  }\n\n  if (part) result.push(part);\n  return result;\n}; // convert value into text representation using the schema\n\nexport var valueToText = function valueToText(value, schema) {\n  // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n  if (!value || Array.isArray(value) && !value.length) return '';\n  var text = '';\n  var dates = (Array.isArray(value) ? value : [value]).map(function (v) {\n    return new Date(v);\n  });\n  var dateIndex = 0;\n  var parts = {};\n  schema.forEach(function (part) {\n    var _char = part[0].toLowerCase(); // advance dateIndex if we already have this part\n\n\n    while (dateIndex < dates.length && (Number.isNaN(dates[dateIndex].date) || (_char === 'm' || _char === 'd' || _char === 'y') && parts[part])) {\n      dateIndex += 1;\n      parts = {};\n    }\n\n    var date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += (\"0\" + (date.getMonth() + 1)).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += (\"0\" + date.getDate()).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else text += part;\n  });\n  return text;\n};\nvar charCodeZero = '0'.charCodeAt(0);\nvar charCodeNine = '9'.charCodeAt(0);\n\nvar pullDigits = function pullDigits(text, index) {\n  var end = index;\n\n  while (text.charCodeAt(end) >= charCodeZero && text.charCodeAt(end) <= charCodeNine) {\n    end += 1;\n  }\n\n  return text.slice(index, end);\n};\n\nexport var textToValue = function textToValue(text, schema) {\n  if (!text) return undefined;\n  var result;\n\n  var addDate = function addDate(parts) {\n    // do a little sanity checking on the values\n    if (!parts.m || !parts.d || !parts.y || parts.y.length < 4 || parts.m.length > 2 || parts.d.length > 2 || parts.m > 12 || parts.d > 31) return parts;\n    var date = new Date(parts.y, parts.m - 1, parts.d).toISOString();\n    if (!result) result = date; // single\n    else if (Array.isArray(result)) result.push(date); // second\n      else result = [result, date]; // third and beyond, unused?\n\n    return {};\n  };\n\n  var parts = {};\n  var index = 0;\n  schema.forEach(function (part) {\n    if (index < text.length) {\n      var _char2 = part[0].toLowerCase();\n\n      if (parts[_char2] !== undefined) parts = addDate(parts);\n\n      if (_char2 === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (_char2 === 'd') {\n        parts.d = pullDigits(text, index);\n        index += parts.d.length;\n      } else if (_char2 === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  addDate(parts);\n  return result;\n};"]},"metadata":{},"sourceType":"module"}