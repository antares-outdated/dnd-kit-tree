{"ast":null,"code":"import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      showProp = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // item index to be made visible initially\n\n  var _useState = useState(showProp),\n      show = _useState[0],\n      setShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setShow(undefined);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };","map":{"version":3,"sources":["C:/Users/antaresofficial/Desktop/tree/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["React","useEffect","useMemo","useRef","useState","useLayoutEffect","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","calculateLastPageBound","show","step","Math","floor","InfiniteScroll","_ref","children","_ref$items","items","onMore","renderMarker","replace","showProp","_ref$step","_useState","setShow","lastPage","length","_useState2","renderPageBounds","setRenderPageBounds","_useState3","pageHeights","setPageHeights","_useState4","pendingLength","setPendingLength","aboveMarkerRef","belowMarkerRef","scrollParents","evaluate","scrollParent","top","height","document","documentElement","scrollTop","body","window","innerHeight","rect","getBoundingClientRect","offset","nextBeginPage","index","pagesHeight","nextEndPage","undefined","max","showPage","min","timer","debounce","clearTimeout","setTimeout","current","forEach","sp","addEventListener","removeEventListener","showIndex","showNode","parentNode","item","scrollIntoView","rendered","nextPageHeights","i","lastBottom","topIndex","bottomIndex","_rendered$item$getBou","bottom","concat","_nextPageHeights","aboveHeight","belowHeight","firstIndex","lastIndex","result","marker","createElement","key","ref","flex","cloneElement","push","slice","itemsIndex","child","_marker","renderedMarker","node","InfiniteScrollDoc","process","env","NODE_ENV","require","doc","InfiniteScrollWrapper"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      showProp = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n\n  // item index to be made visible initially\n  var _useState = useState(showProp),\n      show = _useState[0],\n      setShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setShow(undefined);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };"]},"metadata":{},"sourceType":"module"}