{"ast":null,"code":"import _slicedToArray from \"C:/Users/antaresofficial/Desktop/tree/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"C:/Users/antaresofficial/Desktop/tree/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { closestCorners, getViewRect, KeyboardCode } from \"@dnd-kit/core\";\nimport { getProjection } from \"./utilities\";\nvar directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\nvar horizontal = [KeyboardCode.Left, KeyboardCode.Right];\nexport var sortableTreeKeyboardCoordinates = function sortableTreeKeyboardCoordinates(context, indentationWidth) {\n  return function (event, _ref) {\n    var active = _ref.active,\n        currentCoordinates = _ref.currentCoordinates,\n        _ref$context = _ref.context,\n        over = _ref$context.over,\n        translatedRect = _ref$context.translatedRect,\n        droppableContainers = _ref$context.droppableContainers;\n\n    if (directions.includes(event.code)) {\n      var _droppableContainers$;\n\n      event.preventDefault();\n\n      if (!translatedRect) {\n        return;\n      }\n\n      var _context$current = context.current,\n          items = _context$current.items,\n          offset = _context$current.offset;\n\n      if (horizontal.includes(event.code) && (over === null || over === void 0 ? void 0 : over.id)) {\n        var _getProjection = getProjection(items, active, over.id, offset, indentationWidth),\n            depth = _getProjection.depth,\n            maxDepth = _getProjection.maxDepth,\n            minDepth = _getProjection.minDepth;\n\n        switch (event.code) {\n          case KeyboardCode.Left:\n            if (depth > minDepth) {\n              return _objectSpread(_objectSpread({}, currentCoordinates), {}, {\n                x: currentCoordinates.x - indentationWidth\n              });\n            }\n\n            break;\n\n          case KeyboardCode.Right:\n            if (depth < maxDepth) {\n              return _objectSpread(_objectSpread({}, currentCoordinates), {}, {\n                x: currentCoordinates.x + indentationWidth\n              });\n            }\n\n            break;\n        }\n\n        return undefined;\n      }\n\n      var layoutRects = [];\n      var overRect = (over === null || over === void 0 ? void 0 : over.id) ? (_droppableContainers$ = droppableContainers[over.id]) === null || _droppableContainers$ === void 0 ? void 0 : _droppableContainers$.rect.current : undefined;\n      Object.entries(droppableContainers).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            id = _ref3[0],\n            container = _ref3[1];\n\n        if ((container === null || container === void 0 ? void 0 : container.disabled) || !overRect) {\n          return;\n        }\n\n        var rect = container === null || container === void 0 ? void 0 : container.rect.current;\n\n        if (!rect) {\n          return;\n        }\n\n        switch (event.code) {\n          case KeyboardCode.Down:\n            if (overRect.offsetTop < rect.offsetTop) {\n              layoutRects.push([id, rect]);\n            }\n\n            break;\n\n          case KeyboardCode.Up:\n            if (overRect.offsetTop > rect.offsetTop) {\n              layoutRects.push([id, rect]);\n            }\n\n            break;\n        }\n      });\n      var closestId = closestCorners(layoutRects, translatedRect);\n\n      if (closestId && (over === null || over === void 0 ? void 0 : over.id)) {\n        var _droppableContainers$2, _droppableContainers$3;\n\n        var newNode = (_droppableContainers$2 = droppableContainers[closestId]) === null || _droppableContainers$2 === void 0 ? void 0 : _droppableContainers$2.node.current;\n        var activeNodeRect = (_droppableContainers$3 = droppableContainers[active]) === null || _droppableContainers$3 === void 0 ? void 0 : _droppableContainers$3.rect.current;\n\n        if (newNode && activeNodeRect) {\n          var newRect = getViewRect(newNode);\n          var newItem = items.find(function (_ref4) {\n            var id = _ref4.id;\n            return id === closestId;\n          });\n          var activeItem = items.find(function (_ref5) {\n            var id = _ref5.id;\n            return id === active;\n          });\n\n          if (newItem && activeItem) {\n            var _getProjection2 = getProjection(items, active, closestId, (newItem.depth - activeItem.depth) * indentationWidth, indentationWidth),\n                _depth = _getProjection2.depth;\n\n            var _offset = newRect.offsetTop > activeNodeRect.offsetTop ? Math.abs(activeNodeRect.height - newRect.height) : 0;\n\n            var newCoordinates = {\n              x: newRect.left + _depth * indentationWidth,\n              y: newRect.top + _offset\n            };\n            return newCoordinates;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  };\n};","map":{"version":3,"sources":["C:/Users/antaresofficial/Desktop/tree/src/components/keyboardCoordinates.ts"],"names":["closestCorners","getViewRect","KeyboardCode","getProjection","directions","Down","Right","Up","Left","horizontal","sortableTreeKeyboardCoordinates","context","indentationWidth","event","active","currentCoordinates","over","translatedRect","droppableContainers","includes","code","preventDefault","current","items","offset","id","depth","maxDepth","minDepth","x","undefined","layoutRects","overRect","rect","Object","entries","forEach","container","disabled","offsetTop","push","closestId","newNode","node","activeNodeRect","newRect","newItem","find","activeItem","Math","abs","height","newCoordinates","left","y","top"],"mappings":"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","sourcesContent":["import {\r\n  closestCorners,\r\n  getViewRect,\r\n  KeyboardCode,\r\n  RectEntry,\r\n  KeyboardCoordinateGetter\r\n} from \"@dnd-kit/core\";\r\n\r\nimport type { SensorContext } from \"./types\";\r\nimport { getProjection } from \"./utilities\";\r\n\r\nconst directions: string[] = [\r\n  KeyboardCode.Down,\r\n  KeyboardCode.Right,\r\n  KeyboardCode.Up,\r\n  KeyboardCode.Left\r\n];\r\n\r\nconst horizontal: string[] = [KeyboardCode.Left, KeyboardCode.Right];\r\n\r\nexport const sortableTreeKeyboardCoordinates: (\r\n  context: SensorContext,\r\n  indentationWidth: number\r\n) => KeyboardCoordinateGetter = (context, indentationWidth) => (\r\n  event,\r\n  {\r\n    active,\r\n    currentCoordinates,\r\n    context: { over, translatedRect, droppableContainers }\r\n  }\r\n) => {\r\n  if (directions.includes(event.code)) {\r\n    event.preventDefault();\r\n\r\n    if (!translatedRect) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      current: { items, offset }\r\n    } = context;\r\n\r\n    if (horizontal.includes(event.code) && over?.id) {\r\n      const { depth, maxDepth, minDepth } = getProjection(\r\n        items,\r\n        active,\r\n        over.id,\r\n        offset,\r\n        indentationWidth\r\n      );\r\n\r\n      switch (event.code) {\r\n        case KeyboardCode.Left:\r\n          if (depth > minDepth) {\r\n            return {\r\n              ...currentCoordinates,\r\n              x: currentCoordinates.x - indentationWidth\r\n            };\r\n          }\r\n          break;\r\n        case KeyboardCode.Right:\r\n          if (depth < maxDepth) {\r\n            return {\r\n              ...currentCoordinates,\r\n              x: currentCoordinates.x + indentationWidth\r\n            };\r\n          }\r\n          break;\r\n      }\r\n\r\n      return undefined;\r\n    }\r\n\r\n    const layoutRects: RectEntry[] = [];\r\n\r\n    const overRect = over?.id\r\n      ? droppableContainers[over.id]?.rect.current\r\n      : undefined;\r\n\r\n    Object.entries(droppableContainers).forEach(([id, container]) => {\r\n      if (container?.disabled || !overRect) {\r\n        return;\r\n      }\r\n\r\n      const rect = container?.rect.current;\r\n\r\n      if (!rect) {\r\n        return;\r\n      }\r\n\r\n      switch (event.code) {\r\n        case KeyboardCode.Down:\r\n          if (overRect.offsetTop < rect.offsetTop) {\r\n            layoutRects.push([id, rect]);\r\n          }\r\n          break;\r\n        case KeyboardCode.Up:\r\n          if (overRect.offsetTop > rect.offsetTop) {\r\n            layoutRects.push([id, rect]);\r\n          }\r\n          break;\r\n      }\r\n    });\r\n\r\n    const closestId = closestCorners(layoutRects, translatedRect);\r\n\r\n    if (closestId && over?.id) {\r\n      const newNode = droppableContainers[closestId]?.node.current;\r\n      const activeNodeRect = droppableContainers[active]?.rect.current;\r\n\r\n      if (newNode && activeNodeRect) {\r\n        const newRect = getViewRect(newNode);\r\n        const newItem = items.find(({ id }) => id === closestId);\r\n        const activeItem = items.find(({ id }) => id === active);\r\n\r\n        if (newItem && activeItem) {\r\n          const { depth } = getProjection(\r\n            items,\r\n            active,\r\n            closestId,\r\n            (newItem.depth - activeItem.depth) * indentationWidth,\r\n            indentationWidth\r\n          );\r\n          const offset =\r\n            newRect.offsetTop > activeNodeRect.offsetTop\r\n              ? Math.abs(activeNodeRect.height - newRect.height)\r\n              : 0;\r\n\r\n          const newCoordinates = {\r\n            x: newRect.left + depth * indentationWidth,\r\n            y: newRect.top + offset\r\n          };\r\n\r\n          return newCoordinates;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}